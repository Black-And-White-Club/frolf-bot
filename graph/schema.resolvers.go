package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"strconv"

	"github.com/romero-jace/tcr-bot/graph/model"
)

// CreateUser  is the resolver for the createUser  field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	// Correctly call the CreateUser  method on the UserService
	user, err := r.UserServices.UserService.CreateUser(ctx, input)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// ScheduleRound resolver
func (r *mutationResolver) ScheduleRound(ctx context.Context, input model.RoundInput) (*model.Round, error) {
	creatorID, err := GetUserIDFromContext(ctx) // Implement this function to get the user ID from the context
	if err != nil {
		return nil, err
	}

	return r.ScoringServices.RoundService.ScheduleRound(ctx, input, creatorID)
}

// JoinRound resolver
func (r *mutationResolver) JoinRound(ctx context.Context, input model.JoinRoundInput) (*model.Round, error) {
	// Access the fields of the input struct
	roundID := input.RoundID
	userID := input.UserID
	response := input.Response

	// Call your service method with the extracted values
	return r.ScoringServices.RoundService.JoinRound(ctx, roundID, userID, response) // Use the correct service
}

// SubmitScore resolver
func (r *mutationResolver) SubmitScore(ctx context.Context, roundID string, userID string, score int) (*model.Round, error) {
	// Prepare the scores map
	scores := map[string]string{userID: strconv.Itoa(score)}

	// Call the SubmitScore method from RoundService
	round, err := r.ScoringServices.RoundService.SubmitScore(ctx, roundID, scores)
	if err != nil {
		return nil, err
	}

	return round, nil
}

// FinalizeRound resolver
func (r *mutationResolver) FinalizeRound(ctx context.Context, roundID string) (*model.Round, error) {
	editorID, err := GetUserIDFromContext(ctx) // Implement this function to get the user ID from the context
	if err != nil {
		return nil, err
	}

	return r.ScoringServices.RoundService.FinalizeRound(ctx, roundID, editorID)
}

// EditRound is the resolver for the editRound field.
func (r *mutationResolver) EditRound(ctx context.Context, roundID string, input model.RoundInput) (*model.Round, error) {
	panic(fmt.Errorf("not implemented: EditRound - editRound"))
}

// DeleteRound is the resolver for the deleteRound field.
func (r *mutationResolver) DeleteRound(ctx context.Context, roundID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteRound - deleteRound"))
}

// GetUser  is the resolver for the getUser  field.
func (r *queryResolver) GetUser(ctx context.Context, discordID string) (*model.User, error) {
	user, err := r.UserServices.GetUser(ctx, discordID)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// GetLeaderboard is the resolver for the getLeaderboard field.
func (r *queryResolver) GetLeaderboard(ctx context.Context) (*model.Leaderboard, error) {
	leaderboard, err := r.LeaderboardService.GetLeaderboard(ctx) // Use LeaderboardService
	if err != nil {
		return nil, err
	}
	return leaderboard, nil
}

// GetRounds is the resolver for the getRounds field.
func (r *queryResolver) GetRounds(ctx context.Context, limit *int, offset *int) ([]*model.Round, error) {
	rounds, err := r.ScoringServices.RoundService.GetRounds(ctx, limit, offset)
	if err != nil {
		return nil, err
	}
	return rounds, nil
}

// GetUser Score is the resolver for the getUser Score field.
func (r *queryResolver) GetUserScore(ctx context.Context, userID string) (*int, error) {
	score, err := r.ScoringServices.ScoreService.GetUserScore(ctx, userID) // Call the method from ScoreService
	if err != nil {
		return nil, err
	}
	return &score, nil // Return a pointer to the score
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
